# Set up protocol confirmation/rejection for analyzers, as well as any further
# Zeek-specific analysis.

module Zeek_RESP;

import RESP;
import zeek;

# Any error bubbling up to the top unit will trigger a protocol rejection.
on RESP::Data::%done {
    zeek::confirm_protocol();
}

on RESP::Data::%error {
    zeek::reject_protocol("error while parsing RESP data");
}

type ZeekData = tuple<
    optional<bytes>, 
    optional<bytes>, 
    optional<int64>,
    optional<bytes>, 
    #optional<vector<ZeekData>>, # TODO: This segfaults because recursive type :(
    bool,
    optional<bool>,
    optional<real>,
    optional<string>, 
    optional<bytes>, 
    optional<bytes>, 
>;

public function create_data(data: RESP::Data): ZeekData {
    local simple_string: optional<bytes>;
    local simple_error: optional<bytes>;
    local i: optional<int64>;
    local bulk_string: optional<bytes>;
    #local array: optional<vector<ZeekData>>;
    local null: bool;
    local boolean: optional<bool>;
    local double: optional<real>;
    local big_num: optional<string>;
    local bulk_error: optional<bytes>;
    local verbatim_string: optional<bytes>;
    if (data?.simple_string)
        simple_string = data.simple_string.content;
    if (data?.simple_error)
        simple_error = data.simple_error.content;
    if (data?.integer)
        i = data.integer.int;
    if (data?.bulk_string)
        bulk_string = data.bulk_string.content;
    #if (data?.array) {
    #    for ( data in data.array.elements ) {
    #        array.push_back(data);
    #    }
    #}
    if (data?.null)
        null = True;
    else
        null = False;
    if (data?.boolean)
        boolean = data.boolean.val;
    if (data?.double)
        double = data.double.val;
    if (data?.big_num)
        big_num = data.big_num.val;
    if (data?.bulk_error)
        bulk_error = data.bulk_error.content;
    if (data?.verbatim_string)
        verbatim_string = data.verbatim_string.content;
    return (simple_string, simple_error, i, bulk_string, null, boolean, double, big_num, bulk_error, verbatim_string);
}

type Command = enum {
    SET,
    GET,
    PUBLISH,
    SUBSCRIBE,
};

public function command_from(arr: RESP::Array): optional<Command> {
    if (arr.num_elements < 1)
        return Null;

    local first = arr.elements[0];
    if (!first?.bulk_string)
        return Null;

    local cmd_bytes = first.bulk_string.content;

    local cmd: optional<Command> = Null;
    switch (cmd_bytes.lower()) {
        case b"set": cmd = Command::SET;
        case b"get": cmd = Command::GET;
        case b"publish": cmd = Command::PUBLISH;
        case b"subscribe": cmd = Command::SUBSCRIBE;
        default: cmd = Null;
    }

    return cmd;
}

type Set = tuple<
    bytes,
    bytes,
>;

public function make_set(arr: RESP::Array): Set {
    return (arr.elements[1].bulk_string.content, arr.elements[2].bulk_string.content);
}

# Convenience method to avoid comparison with an optional in the evt
public function is_set(arr: RESP::Array): bool {
    # SET key value
    if (arr.num_elements < 3)
        return False;
    local cmd = command_from(arr);
    return cmd && (*cmd == Command::SET);
}

type Get = tuple<bytes>;

public function make_get(arr: RESP::Array): Get {
    return (arr.elements[1].bulk_string.content, );
}

# Convenience method to avoid comparison with an optional in the evt
public function is_get(arr: RESP::Array): bool {
    # SET key value
    if (arr.num_elements != 2)
        return False;
    local cmd = command_from(arr);
    return cmd && (*cmd == Command::GET);
}

type Publish = tuple<
    bytes,
    bytes,
>;

public function make_publish(arr: RESP::Array): Publish {
    return (arr.elements[1].bulk_string.content, arr.elements[2].bulk_string.content);
}

public function is_publish(arr: RESP::Array): bool {
    # PUBLISH channel message
    if (arr.num_elements < 3)
        return False;
    local cmd = command_from(arr);
    return cmd && (*cmd == Command::PUBLISH);
}

type Subscribe = tuple<bytes>;

public function make_subscribe(arr: RESP::Array): Subscribe {
    return (arr.elements[1].bulk_string.content, );
}

public function is_subscribe(arr: RESP::Array): bool {
    # PUBLISH channel message
    if (arr.num_elements < 2)
        return False;
    local cmd = command_from(arr);
    return cmd && (*cmd == Command::SUBSCRIBE);
}
